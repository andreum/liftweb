package net.liftweb.mapper

import net.liftweb.util._

abstract class DriverType(val name : String) {
  def binaryColumnType: String
  def clobColumnType: String
  def booleanColumnType: String
  def dateTimeColumnType: String
  def integerColumnType: String
  def integerIndexColumnType: String
  def enumColumnType: String
  def longForeignKeyColumnType: String
  def longIndexColumnType: String
  def enumListColumnType: String
  def longColumnType: String
  def doubleColumnType: String
  def varcharColumnType = "VARCHAR" 

  def supportsForeignKeys_? : Boolean = false
  def createTablePostpend: String = ""

  /**
   * Whether this database supports LIMIT clause in SELECTs.
   */ 
  def brokenLimit_? : Boolean = false

  /**
   * Whether the primary key has been defined by the index column.
   */
  def pkDefinedByIndexColumn_? : Boolean = false

  /**
   * Maximum value of the LIMIT clause in SELECT.
   */
  def maxSelectLimit : String = java.lang.Long.MAX_VALUE.toString

  /**
   * Whether this database supports returning autogenerated keys (JDBC3)
   */
  def brokenAutogeneratedKeys_? : Boolean = false
      
  /**
    * Is the foreign key mechanism so totally broken that it doesn't allow a "RETURNING" in the query
    */
  def wickedBrokenAutogeneratedKeys_? : Boolean = false
 
  /**
   * Insert and update use "returning into" clause
   */
  def returningIntoClause_? = false
  /**
   * Name of the default db schema. If not set, then the schema is assumed to
   * equal the db user name.
   */
  def defaultSchemaName : Can[String] = Empty
  
  /**
   * returns a ResultSet of a PreparedStatement
   */
  def executeReturning(st:java.sql.PreparedStatement) = st.executeQuery
  
  def registerReturnParameter(st:java.sql.PreparedStatement, colNum:Int, sqlType:Int) {
    throw new UnsupportedOperationException
  }
  
  def createClobJdbcObject(conn:java.sql.Connection, data:String):Tuple2[Object,Option[()=>Unit]] = (data,None)
}

object DerbyDriver extends DriverType("Apache Derby") {
  def binaryColumnType = "LONG VARCHAR FOR BIT DATA"
  def booleanColumnType = "SMALLINT"
  def clobColumnType = "LONG VARCHAR"    
  def dateTimeColumnType = "TIMESTAMP"
  def integerColumnType = "INTEGER"
  def integerIndexColumnType = "INTEGER NOT NULL GENERATED ALWAYS AS IDENITY"
  def enumColumnType = "BIGINT"
  def longForeignKeyColumnType = "BIGINT"
  def longIndexColumnType = "BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY"
  def enumListColumnType = "BIGINT"
  def longColumnType = "BIGINT"
  def doubleColumnType = "DOUBLE"

  override def brokenLimit_? : Boolean = true
}

object MySqlDriver extends DriverType("MySQL") {
  def binaryColumnType = "MEDIUMBLOB"
  def clobColumnType = "LONGTEXT"
  def booleanColumnType = "BOOLEAN"
  def dateTimeColumnType = "DATETIME"
  def integerColumnType = "INTEGER"
  def integerIndexColumnType = "INTEGER NOT NULL AUTO_INCREMENT UNIQUE"
  def enumColumnType = "BIGINT"
  def longForeignKeyColumnType = "BIGINT UNSIGNED"
  def longIndexColumnType = "BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE KEY"
  def enumListColumnType = "BIGINT"
  def longColumnType = "BIGINT"
  def doubleColumnType = "DOUBLE"

  override def createTablePostpend: String = " ENGINE = InnoDB "
}

object H2Driver extends DriverType("H2") {
  def binaryColumnType = "BINARY"
  def clobColumnType = "LONGVARCHAR"    
  def booleanColumnType = "BOOLEAN"
  def dateTimeColumnType = "TIMESTAMP"
  def integerColumnType = "INTEGER"
  def integerIndexColumnType = "INTEGER NOT NULL AUTO_INCREMENT"
  def enumColumnType = "BIGINT"
  def longForeignKeyColumnType = "BIGINT"
  def longIndexColumnType = "BIGINT NOT NULL AUTO_INCREMENT"
  def enumListColumnType = "BIGINT"
  def longColumnType = "BIGINT"
  def doubleColumnType = "DOUBLE"

  /**
   * Whether the primary key has been defined by the index column.
   * H2 creates primary key for a table, when AUTO_INCREMENT type
   * is used.
   */
  override def pkDefinedByIndexColumn_? : Boolean = true

  override def maxSelectLimit = "0";
}

object PostgreSqlDriver extends DriverType("PostgreSQL") {
  def binaryColumnType = "BYTEA"
  def clobColumnType = "TEXT"    
  def booleanColumnType = "BOOLEAN"
  def dateTimeColumnType = "TIMESTAMP"
  def integerColumnType = "INTEGER"
  def integerIndexColumnType = "SERIAL"
  def enumColumnType = "BIGINT"
  def longForeignKeyColumnType = "BIGINT"
  def longIndexColumnType = "BIGSERIAL"
  def enumListColumnType = "BIGINT"
  def longColumnType = "BIGINT"
  def doubleColumnType = "DOUBLE"

  /**
   * Whether this database supports returning autogenerated keys (JDBC3)
   */
  override def brokenAutogeneratedKeys_? : Boolean = true

  override def wickedBrokenAutogeneratedKeys_? : Boolean = true      
      
  override def maxSelectLimit = "ALL"

  /**
   * "$user" schema is searched before "public", but it does not exist by default,
   * so "public" is our default choice.
   */
  override def defaultSchemaName : Can[String] = Full("public")
}

object OracleDriver extends DriverType("Oracle") {
  import java.sql.{Connection,PreparedStatement,ResultSet}
  def binaryColumnType = "BLOB"
  def clobColumnType = "CLOB"    
  def booleanColumnType = "BOOLEAN"
  def dateTimeColumnType = "TIMESTAMP"
  def integerColumnType = "NUMBER"
  def integerIndexColumnType = "NUMBER"
  def enumColumnType = "NUMBER"
  def longForeignKeyColumnType = "NUMBER"
  def longIndexColumnType = "NUMBER"
  def enumListColumnType = "NUMBER"
  def longColumnType = "NUMBER"
  def doubleColumnType = "DECIMAL"
  override def varcharColumnType = "VARCHAR2" //Oracle is the only exception...

  /**
  * some constante we need for reflection calls where the scala type are a bit too clever
  */
  private val objFalse = java.lang.Boolean.FALSE
  private val obj10 = new java.lang.Integer(10)
  private val obj1l = new java.lang.Long(1)
  
  private lazy val clobClass = Class.forName("oracle.sql.CLOB")
  private lazy val opsClass = Class.forName("oracle.jdbc.OraclePreparedStatement")
  private lazy val createTemporary = clobClass.getMethod("createTemporary",Array(classOf[Connection], classOf[boolean], classOf[int]))
  private lazy val freeTemporary = clobClass.getMethod("freeTemporary",Array(clobClass))
  private lazy val setString = clobClass.getMethod("setString", Array(classOf[long], classOf[String]))
  private lazy val getReturnResultSet = opsClass.getMethod("getReturnResultSet", Array())
  private lazy val registerReturnParameter = opsClass.getMethod("registerReturnParameter", Array(classOf[int],classOf[int]))
  
  private def freeTemporary(clob:Object) {
    try {
      freeTemporary.invoke(null,Array(clob))
    } catch {
      case ite:java.lang.reflect.InvocationTargetException => ite.getCause match {
        case sqle:java.sql.SQLException => () //might have been closed already
        case null => throw ite
        case t:Throwable => throw t
      }
    }
  }
  override def createClobJdbcObject(conn:Connection, data:String) = {
    try {
      val clob = createTemporary.invoke(null,Array(conn,objFalse,obj10)) //CLOB.createTemporary(conn,false,CLOB.DURATION_SESSION)
      setString.invoke(clob,Array(obj1l,data))
      (clob,Some(()=>freeTemporary(clob)))
    } catch {
      case ite:java.lang.reflect.InvocationTargetException => ite.getCause match {
        case null => throw ite
        case t:Throwable => throw t
      }
    }
  }
  
  /**
   * Whether this database supports returning autogenerated keys (JDBC3)
   */
  override def brokenAutogeneratedKeys_? : Boolean = true // Oracle returns rowids...

  override def wickedBrokenAutogeneratedKeys_? : Boolean = false      
      
  override def brokenLimit_? : Boolean = true
  
  override def returningIntoClause_? : Boolean = true
  
  override def executeReturning(st:PreparedStatement):ResultSet = {
    try {
      st.execute
      getReturnResultSet.invoke(st,Array()).asInstanceOf[ResultSet]
    } catch {
      case ite:java.lang.reflect.InvocationTargetException => ite.getCause match {
        case null => throw ite
        case t:Throwable => throw t
      }
    }
  }
  
  override def registerReturnParameter(st:java.sql.PreparedStatement, colNum:Int, sqlType:Int) {
    try {
      registerReturnParameter.invoke(st,Array(colNum.asInstanceOf[java.lang.Integer],sqlType.asInstanceOf[java.lang.Integer]))
    } catch {
      case ite:java.lang.reflect.InvocationTargetException => ite.getCause match {
        case null => throw ite
        case t:Throwable => throw t
      }
    }
  }
}
